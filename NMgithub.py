#!/usr/bin/env python3

# Dustin Marchak
# CSCI 5180 - Midterm Lab
# NMgithub.py - Create a GitHub repo, push SNMP output files, and sync modified files.

# imports
import os
import sys
import glob
import json
import base64
import getpass
import requests
from git import Repo
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives import hashes
from cryptography.fernet import Fernet, InvalidToken

# Function Definitions

# Path to the encrypted credentials file (stored alongside this script)
CREDS_FILE = os.path.join(os.path.dirname(os.path.abspath(__file__)), ".github_creds.enc")


def derive_key(password, salt):
    # Derive a Fernet encryption key from a password and salt using PBKDF2.
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=480000,
    )
    return base64.urlsafe_b64encode(kdf.derive(password.encode()))


def setup_credentials():
    # First-time setup: encrypt and store GitHub username and token.
    print("\n--- First-time credential setup ---")
    username = input("GitHub username: ").strip()
    token = input("GitHub personal access token: ").strip()
    password = getpass.getpass("Create an encryption password: ")

    # Generate a random salt and derive the encryption key
    salt = os.urandom(16)
    key = derive_key(password, salt)
    fernet = Fernet(key)

    # Encrypt the credentials as JSON
    creds = json.dumps({"username": username, "token": token})
    encrypted = fernet.encrypt(creds.encode())

    # Store salt + encrypted data
    with open(CREDS_FILE, "wb") as f:
        f.write(salt + encrypted)

    print(f"  Credentials encrypted and saved to {os.path.basename(CREDS_FILE)}")
    return username, token


def load_credentials():
    # Load and decrypt stored GitHub credentials using a password prompt.

    if not os.path.exists(CREDS_FILE):
        return setup_credentials()

    password = getpass.getpass("Enter password: ")

    with open(CREDS_FILE, "rb") as f:
        data = f.read()

    # First 16 bytes are the salt, rest is the encrypted data
    salt = data[:16]
    encrypted = data[16:]

    key = derive_key(password, salt)
    fernet = Fernet(key)

    try:
        decrypted = fernet.decrypt(encrypted)
        creds = json.loads(decrypted.decode())
        print("  Credentials decrypted successfully.")
        return creds["username"], creds["token"]
    except InvalidToken:
        print("  Error: Wrong password. Cannot decrypt credentials.")
        sys.exit(1)


def create_github_repo(username, token, repo_name):
    # Create a new repository on GitHub using the REST API.
    # Returns the HTTPS clone URL with the token embedded for authentication.

    print(f"\nCreating GitHub repository '{repo_name}'...")

    response = requests.post(
        "https://api.github.com/user/repos",
        headers={
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json",
        },
        json={
            "name": repo_name,
            "private": False,
            "description": "CSCI 5180 Midterm Lab - SNMP Network Management",
        },
    )

    if response.status_code == 201:
        print(f"  Repository '{repo_name}' created successfully.")
    elif response.status_code == 422:
        print(f"  Repository '{repo_name}' already exists, using existing repo.")
    else:
        print(f"  Error creating repo: {response.status_code} - {response.json().get('message', '')}")
        return None

    # Build the authenticated HTTPS URL for pushing
    remote_url = f"https://{username}:{token}@github.com/{username}/{repo_name}.git"
    return remote_url


def init_local_repo(repo_dir):
    # Initialize a local Git repository if one doesn't already exist.

    if os.path.isdir(os.path.join(repo_dir, ".git")):
        print("  Local git repo already initialized.")
        return Repo(repo_dir)

    print("  Initializing local git repository...")
    repo = Repo.init(repo_dir)
    return repo


def push_snmp_output(repo, remote_url):
    # Stage and push the .txt and .jpg files generated by NMsnmp.py to GitHub.

    print("\nPushing SNMP output files (.txt, .jpg) to GitHub...")
    repo_dir = repo.working_dir

    # Find all .txt and .jpg files in the repo directory
    txt_files = glob.glob(os.path.join(repo_dir, "*.txt"))
    jpg_files = glob.glob(os.path.join(repo_dir, "*.jpg"))
    output_files = txt_files + jpg_files

    if not output_files:
        print("  No .txt or .jpg files found to push.")
        return

    # Stage the output files
    for filepath in output_files:
        filename = os.path.basename(filepath)
        repo.index.add([filename])
        print(f"  Staged: {filename}")

    # Commit the staged files
    repo.index.commit("Add SNMP query results and CPU utilization graph")
    print("  Committed SNMP output files.")

    # Set up the remote and push
    if "origin" not in [r.name for r in repo.remotes]:
        repo.create_remote("origin", remote_url)
    else:
        repo.remotes.origin.set_url(remote_url)

    repo.remotes.origin.push(refspec="HEAD:refs/heads/main")
    print("  Pushed to GitHub.")


def push_modified_files(repo):
    # Compare the local repository against GitHub and push any modified files.

    print("\nChecking for modified files...")

    # Fetch the latest state from GitHub
    repo.remotes.origin.fetch()

    # Get list of changed files (staged, unstaged, and untracked)
    changed_files = []

    # Check for modified tracked files (unstaged changes)
    for item in repo.index.diff(None):
        changed_files.append(item.a_path)

    # Check for staged but uncommitted changes
    for item in repo.index.diff("HEAD"):
        changed_files.append(item.a_path)

    # Check for untracked files
    changed_files.extend(repo.untracked_files)

    # Remove duplicates
    changed_files = list(set(changed_files))

    if not changed_files:
        print("  No modified files found. Repository is up to date.")
        return

    # Stage all modified and untracked files
    print(f"  Found {len(changed_files)} modified/new file(s):")
    for filepath in sorted(changed_files):
        print(f"    {filepath}")
        repo.index.add([filepath])

    # Commit and push
    repo.index.commit("Update modified files")
    repo.remotes.origin.push(refspec="HEAD:refs/heads/main")
    print("  Pushed modified files to GitHub.")


def main():
    # Set working directory and repo name
    repo_dir = os.path.dirname(os.path.abspath(__file__))
    repo_name = "CSCI5180-Midterm"

    # Step 1: Load or set up encrypted GitHub credentials
    username, token = load_credentials()

    # Step 2: Create the GitHub repository
    remote_url = create_github_repo(username, token, repo_name)
    if not remote_url:
        return

    # Step 3: Initialize local git repo
    repo = init_local_repo(repo_dir)

    # Step 4: Push SNMP output files (.txt, .jpg) to GitHub
    push_snmp_output(repo, remote_url)

    # Step 5: Push any modified files (compare local vs GitHub)
    push_modified_files(repo)

    print(f"\nDone. Repository: https://github.com/{username}/{repo_name}")


# namespace check
if __name__ == "__main__":
    main()
